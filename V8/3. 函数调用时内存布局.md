1. 什么是调用栈，以及为什么使用栈来管理函数的调用？
   每个函数在执行的过程中，都有自己的`生命周期`和`作用域`，当`函数执行结束`时，其`作用域`也会被销毁，因此，我们会使用栈这种结构来管理函数的调用过程，我们也把管理函数调用过程的数据结构称之为`调用栈`。函数在执行的过程中，非常符合栈的`先进后出`规则。

2. 调用栈的缺点
   因为栈这种数据结构，是`线性`的，在`内存中是连续`的，而内存中连续的空间非常有限，因此栈是有`最大容量限制`，过多的调用函数，会使得`调用栈溢出`

这里有 2 种`JavaScript`

```js
function foo() {
  console.log(1);
  foo();
}

function foo() {
  console.log("setTimeout", 1);
  setTimeout(foo, 0);
}

function foo() {
  console.log("promise", 1);
  Promise.resolve().then(() => {
    foo();
  });
}
```

第一种，在当前的宏任务，会栈溢出
第二种，在下一个宏任务执行，不会出现栈溢出
第三种，是 js 内部实现的微任务，导致当前宏任务中一直存在任务，从而卡死了 ui，但是不会栈溢出

结论：宏任务，微任务都会开启一个调用栈，不会去复用之前的调用栈

例子：
函数执行

```js
function add(a, b) {
  return a + b;
}

function main() {
  var a = 0;
  var b = 1;
  return add(a, b);
}
```

上面 main 函数执行过程

1. 在当前的宏任务，从内存中开辟出连续的空间，用作调用栈
2. 执行 main 函数，将 a 变量压入栈，再把 b 压入栈中，执行赋值语句
3. 执行 add 函数，和第二步一样
4. add 函数执行完毕，销毁作用域，还要把控制权交给 main 函数，`恢复现场`
