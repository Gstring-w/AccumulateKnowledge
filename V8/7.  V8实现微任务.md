概念：

1. 宏任务
   消息队列中等待被主线程执行的任务
2. 微任务
   可以看成是一个异步任务，执行于主函数之后，当前宏任务执行结束之前

3. 为什么要引入微任务
   为了实时性和效率性之间做的权衡，因为是在当前宏任务执行结束之前，所以避免了主线程卡住，下个宏任务迟迟得不到执行；由于引进微任务在当前的宏任务里，导致了要执行的任务比较臃肿，所以会有效率性。

调用栈 消息队列 主线程 执行上下文

V8 执行一段函数的整个流程

1. 首先 V8 会把主函数放入消息队列中；
2. 主线程从消息队列中拿出一个宏任务，并开辟出一个调用栈（连续的内存空间）；
3. 执行当前的宏任务，在执行之前会创建一个全局执行上下文，将改执行上下文压入调用栈中；
4. 如果遇到 setTimeout 这些能产生宏任务的 api，主线程会交给对应的线程处理，对应的线程会在合适的机会，放入消息队列中；
5. 如果遇到 Promise.resolve 这样可以产生微任务的 api，主线程会在放入一个微任务队列中；
6. 如果当前主函数里又调用了另一个函数，会创建另一个函数的的执行上下文（在改函数执行之前），放入调用栈；
7. 当前函数执行完，调用栈弹出当前执行上下文，把控制权，交个上个函数；
8. 宏任务执行完之前，主线程会执行微任务队列中的微任务；
9. 微任务执行完之后，主线程继续查看消息队列中是否存在任务，继续下一个事件循环。

```js
function foo() {
  return Promise.resolve().then(foo);
}
foo();
```
