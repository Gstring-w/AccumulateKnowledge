## 闭包的产生
> 因为JavaScript可以在函数内部申明函数，而JavaScript采用的是词法作用域（一开始就定义好的作用域）

## 执行上下文

产生：在函数执行前一刻，会创建出执行上下文
1. 形参，实参相统一
2. 函数声明提前

包括：
1. 作用域链
2. 变量对象
3. this

销毁：在执行完函数之后会被销毁

## V8编译会使用惰性编译
> 如果遇到函数声明，V8会自动跳过，不会解析成AST和字节码

这样就会产生问题，无法解析尚未执行的函数语法错误和闭包

如何解决这个问题？
V8使用预编译，用于解析尚未执行的函数语法错误，以及解析尚未执行的函数内部是否有引用到外部变量；如果引用了外部变量，V8在函数执行过后要销毁执行上下文，就会保留引用到的变量

### 问题：下面的情况下，变量a会在栈上，还是在堆中
```javascript
function foo(){
    var a = 0;
}

function foo(){
    var a = 0;
    return function(){
        return a;
    }
}

```
第一个函数执行，a在栈中；第二个函数，因为是闭包，所以先在栈中，预编译阶段会在堆中复制一个一模一样的a，随着foo函数执行完毕，栈中的a会被销毁，只存在堆中的a。