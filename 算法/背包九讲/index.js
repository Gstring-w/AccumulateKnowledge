/**
 * 01背包问题
 * 题目：有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i],求解将哪些物品装入背包可使价值总和最大。
 * 特点：每种物品只有一件，可以选择放或者不放
 *                  集合
 *               /
 *       状态表示
 *    /         \
 * Dp             属性
 *   \
 *      状态计算  -- 集合划分 ( 含不含 i )
 *                 /    \
 *              包含i   不含i
 * 
 * 用f[i][v]来表示前i件物品恰放入一个容量为V的背包可以获得的最大价值。
 * 其状态转移方程为：
 * f[i][v] = max{f[i - 1][v], f[i -1][v-c[i]] + w[i]};
 * 
 * 解析：将前i件物品放入V的背包中 这个子问题，若只考虑第i件物品的策略（放或者不放），那么就转化为一个只牵扯i-1件物品的问题。如果不放第i件物品
 * ，那么问题就转化为 前i-1件物品放入容量为v的背包中 价值为f[i-1][v]；如果放第i件物品，那么问题就转化为 前i-1件物品放剩下的容量为v-c[i]的背包中， 
 * 此时能获得的最大价值就是f[i-1][v - c[i]]再 加上通过放入第i件物品获得的价值w[i];
 */

function max(N, V, c, w) {
  var f = [];
  for (var i = 1; i <= N; i++) {
    for (var v = V; v >= 0; v--) {
      f[v] = Math.max(f[v], f[v - c[i]] + w[i]);
    }
  }
  return f;
}

// 一维数组解决01背包问题

function max1(N, V, c, w) {
  var f = [];
  for (var i = 1; i <= name; i++) {
    ZeroOnePack(c[i], w[i]);
  }
  function ZeroOnePack(cost, weight) {
    for (var v = v; v >= 0; v--) {
      f[v] = Math.max(f[v], f[v - cost] + weight);
    }
  }
}


/**
 * 完全背包问题（每个物品可以取无限次）
 * f[i][v] = max{f[i - 1][v - k * c[i]] + k * w[i]}   0 <= k * c[i] <= v
 * 
 * 
 * 优化：
 * 1. 若两件物品i、j满足c[i]<=c[j]且w[i]>=w[j]，则将物品j去掉，不用考虑。对于随机生成的数据，但是对于特别设计的数据不管用；O(n^2);
 * 2. 将费用大于V的物品去掉，然后使用类型计数排序的做法，计算出费用相同的物品中价值最高的那个。O(V+N);
 */


function max2(){
    for(var i = 1; i <= N; i++){
        for(var v = 0; v < V; V++){
            f[v] = Math.max(f[v],f[v - c[i]] + w[i])
        }
    }
}


/**
 * 多重背包问题
 * q: 有N种物品和一个容量为V的背包，第i种物品最多只有n[i]件可用，每件费用是c[i],价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，
 * 且价值总和最大
 * 
 * 方程：f[v][i] = max{f[i-1][v - k * v[i]] + k * w[i]} 0 <= k <= n[i];
 * 
 * 转化为01背包问题：
 * 将第i种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值均是原来的费用和价值乘以这个系数，使这些系数分别为n[i]，
 */

